I'll show you how to package your Flask application using different methods: [1]

First, create a proper Python package structure: [2]

your_project/
├── app/
│   ├── __init__.py
│   ├── app.py
│   ├── templates/
│   │   └── *.html
│   ├── scripts/
│   │   ├── monitoring_setup.sh
│   │   ├── gke_monitoring_setup.sh
│   │   ├── variables.sh
│   │   └── gke_variables.sh
│   └── config/
│       └── values.yaml
├── requirements.txt
├── setup.py
├── MANIFEST.in
└── README.md

Copy

Insert at cursor
text
Create a setup.py file:

from setuptools import setup, find_packages

setup(
    name="your-project-name",
    version="1.0.0",
    packages=find_packages(),
    include_package_data=True,
    install_requires=[
        'flask',
        # Add other dependencies from your requirements.txt
    ],
    package_data={
        'app': [
            'templates/*',
            'scripts/*',
            'config/*'
        ],
    },
)

Copy

Insert at cursor
python
Create a MANIFEST.in file to include non-Python files:

include requirements.txt
include README.md
recursive-include app/templates *
recursive-include app/scripts *
recursive-include app/config *

Copy

Insert at cursor
text
Create a requirements.txt file if you haven't already: [3]

pip freeze > requirements.txt

Copy

Insert at cursor
bash
Create an empty __init__.py in the app directory to make it a Python package:

# app/__init__.py
from flask import Flask

def create_app():
    app = Flask(__name__)
    return app

Copy

Insert at cursor
python
Update your app.py to use relative paths:

from pathlib import Path
from flask import Flask, render_template
import os

app = Flask(__name__)

# Get the base directory
BASE_DIR = Path(__file__).resolve().parent

# Update paths
SCRIPTS_DIR = BASE_DIR / "scripts"
CONFIG_DIR = BASE_DIR / "config"

# Update file paths
VARIABLES_FILE = SCRIPTS_DIR / "variables.sh"
GKE_VARIABLES_FILE = SCRIPTS_DIR / "gke_variables.sh"
MONITORING_SETUP = SCRIPTS_DIR / "monitoring_setup.sh"
GKE_MONITORING_SETUP = SCRIPTS_DIR / "gke_monitoring_setup.sh"
VALUES_FILE = CONFIG_DIR / "values.yaml"

Copy

Insert at cursor
python
Create a build script ( build.sh):

#!/bin/bash

# Clean previous builds
rm -rf build/ dist/ *.egg-info/

# Create necessary directories
mkdir -p app/scripts app/config

# Copy files to appropriate locations
cp monitoring_setup.sh app/scripts/
cp gke_monitoring_setup.sh app/scripts/
cp variables.sh app/scripts/
cp gke_variables.sh app/scripts/
cp values.yaml app/config/

# Make scripts executable
chmod +x app/scripts/*.sh

# Create Python package
python setup.py sdist bdist_wheel

Copy

Insert at cursor
bash
To build your package:

# Make build script executable
chmod +x build.sh

# Run build script
./build.sh

Copy

Insert at cursor
bash
To install your package:

pip install dist/your-project-name-1.0.0.tar.gz

Copy

Insert at cursor
bash
Alternative Method - Using Docker:

Create a Dockerfile:

FROM python:3.9-slim

WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application files
COPY app/ ./app/
COPY scripts/ ./scripts/
COPY config/ ./config/

# Make scripts executable
RUN chmod +x scripts/*.sh

# Set environment variables
ENV FLASK_APP=app/app.py
ENV FLASK_ENV=production

# Expose port
EXPOSE 5000

# Run application
CMD ["flask", "run", "--host=0.0.0.0"]

Copy

Insert at cursor
dockerfile
Create a .dockerignore file:

__pycache__
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.env
*.egg
*.egg-info/
dist/
build/

Copy

Insert at cursor
text
Build and run the Docker container:

# Build the image
docker build -t your-project-name .

# Run the container
docker run -p 5000:5000 your-project-name

Copy

Insert at cursor
bash
For development, create a docker-compose.yml:

version: '3.8'
services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - ./app:/app/app
      - ./scripts:/app/scripts
      - ./config:/app/config
    environment:
      - FLASK_ENV=development
      - FLASK_APP=app/app.py
    command: flask run --host=0.0.0.0 --reload

Copy

Insert at cursor
yaml
To use docker-compose:

docker-compose up --build

Copy

Insert at cursor
bash
Choose the packaging method that best suits your needs:

Use the Python package approach if you want to distribute your application as a pip-installable package

Use the Docker approach if you want to containerize your application for easier deployment and consistency across environments

Both methods will maintain your folder structure and ensure all necessary files are included in the package.